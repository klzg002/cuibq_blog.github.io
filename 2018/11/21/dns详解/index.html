<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="chinese">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.5.0" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.5.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.5.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.5.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.5.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="CoreDNS手册什么是corednscoredns是go语言写的dns Server，比起之前的bind PowerDNS 和 Unbound优势，比较灵活，有自己的插件链。  CoreDNS is powered by plugins.  插件可以单独使用，也可以一起工作以执行“DNS功能”。目前默认的CoreDNS安装中包含大约30个插件，但也有一大堆外部插件可以编译到CoreDNS中以扩展">
<meta name="keywords" content="DNS,CoreDNS">
<meta property="og:type" content="article">
<meta property="og:title" content="dns详解">
<meta property="og:url" content="http://blog.cuibq.com/2018/11/21/dns详解/index.html">
<meta property="og:site_name" content="我的七秒记忆">
<meta property="og:description" content="CoreDNS手册什么是corednscoredns是go语言写的dns Server，比起之前的bind PowerDNS 和 Unbound优势，比较灵活，有自己的插件链。  CoreDNS is powered by plugins.  插件可以单独使用，也可以一起工作以执行“DNS功能”。目前默认的CoreDNS安装中包含大约30个插件，但也有一大堆外部插件可以编译到CoreDNS中以扩展">
<meta property="og:locale" content="chinese">
<meta property="og:image" content="http://blog.cuibq.com/2018/11/21/dns详解/query-processing.png">
<meta property="og:image" content="http://blog.cuibq.com/2018/11/21/dns详解/CoreDNS-Corefile.png">
<meta property="og:updated_time" content="2018-11-28T11:27:32.318Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dns详解">
<meta name="twitter:description" content="CoreDNS手册什么是corednscoredns是go语言写的dns Server，比起之前的bind PowerDNS 和 Unbound优势，比较灵活，有自己的插件链。  CoreDNS is powered by plugins.  插件可以单独使用，也可以一起工作以执行“DNS功能”。目前默认的CoreDNS安装中包含大约30个插件，但也有一大堆外部插件可以编译到CoreDNS中以扩展">
<meta name="twitter:image" content="http://blog.cuibq.com/2018/11/21/dns详解/query-processing.png">






  <link rel="canonical" href="http://blog.cuibq.com/2018/11/21/dns详解/">



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>dns详解 | 我的七秒记忆</title>
  











  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="chinese">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">我的七秒记忆</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">我只有7、8秒的记忆</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.cuibq.com/2018/11/21/dns详解/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="cuibq">
      <meta itemprop="description" content="工作生活中总有很多随着时间被遗忘的东西,所以我决定写下来,防止老了记不住">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="我的七秒记忆">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">dns详解
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-11-21 14:11:03" itemprop="dateCreated datePublished" datetime="2018-11-21T14:11:03+08:00">2018-11-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-11-28 19:27:32" itemprop="dateModified" datetime="2018-11-28T19:27:32+08:00">2018-11-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing"><a href="/categories/IT/" itemprop="url" rel="index"><span itemprop="name">IT</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="CoreDNS手册"><a href="#CoreDNS手册" class="headerlink" title="CoreDNS手册"></a>CoreDNS手册</h1><h2 id="什么是coredns"><a href="#什么是coredns" class="headerlink" title="什么是coredns"></a>什么是coredns</h2><p>coredns是go语言写的dns Server，比起之前的bind PowerDNS 和 Unbound优势，比较灵活，有自己的插件链。</p>
<blockquote>
<p>CoreDNS is powered by plugins.</p>
</blockquote>
<p>插件可以单独使用，也可以一起工作以执行“DNS功能”。<br>目前默认的CoreDNS安装中包含大约30个插件，但也有一大堆外部插件可以编译到CoreDNS中以扩展其功能。<br>它是新晋的 CNCF 孵化项目（社区也计划将其作为 Kubernetes 默认的 DNS 方案）。<br>CoreDNS 的目标是成为 cloud-native 环境下的 DNS 服务器和服务发现解决方案。</p>
<blockquote>
<p>Our goal is to make CoreDNS the cloud-native DNS server and service discovery solution.</p>
</blockquote>
<p>CoreDNS特性：</p>
<ul>
<li>插件化</li>
<li>配置简单化</li>
<li>一体化的解决方案</li>
</ul>
<h2 id="编译与运行"><a href="#编译与运行" class="headerlink" title="编译与运行"></a>编译与运行</h2><p>推荐使用 Docker 方式来编译代码（Go &gt; 1.9）：</p>
<p><code>$ docker run --rm -i -t -v $PWD:/go/src/github.com/coredns/coredns   -w /go/src/github.com/coredns/coredns golang:1.10 make</code><br>编译最后将生成一个可执行文件 coredns，因为 CoreDNS 是一个通用 DNS 服务器，所以无需依赖特定的场景，可以直接执行：</p>
<p><code>$ ./coredns -dns.port=1053</code></p>
<p>用 dig 工具进行测试（查找 A 记录）：</p>
<p><code>$ dig @localhost -p 1053 A whoami.example.org</code></p>
<p>CoreDNS 的 code base 并未对所有的依赖做 vendor 化管理，所以编译时期仍需要联网下载某些依赖组件。之所以采用这种方式，更多是因为其外部插件总是会引入不同的依赖组件，为了能让插件也能顺利编译，所以需要采用 go get 的方式获取其他依赖组件。关于这个问题，可参考讨论。</p>
<h2 id="Corefile-介绍"><a href="#Corefile-介绍" class="headerlink" title="Corefile 介绍"></a>Corefile 介绍</h2><p>Corefile 是 CoreDNS 的配置文件（源于 Caddy 框架的配置文件 Caddyfile），它定义了：</p>
<ul>
<li>server 以什么协议监听在哪个端口（可以同时定义多个 server 监听不同端口）</li>
<li>server 负责哪个 zone 的权威（authoritative）DNS 解析</li>
<li>server 将加载哪些插件</li>
</ul>
<p>常见地，一个典型的 Corefile 格式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ZONE:[PORT] &#123;</span><br><span class="line">	[PLUGIN] ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>ZONE</code>：定义 server 负责的 zone，PORT 是可选项，默认为 53；</li>
<li><code>PLUGIN</code>：定义 server 所要加载的 plugin。每个 plugin 可以有多个参数；</li>
</ul>
<p>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line">    chaos CoreDNS-001</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述配置文件表达的是：server 负责根域 . 的解析，其中 plugin 是 chaos 且没有参数。<br>定义 server</p>
<p>一个最简单的配置文件可以为：</p>
<p><code>.{}</code></p>
<p>即 server 监听 53 端口并不使用插件。如果此时在定义其他 server，要保证监听端口不冲突；如果是在原来 server 增加 zone，则要保证 zone 之间不冲突，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.    &#123;&#125;</span><br><span class="line">.:54 &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个 server 运行于 54 端口并负责根域 . 的解析。</p>
<p>又如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">example.org &#123;</span><br><span class="line">    whoami</span><br><span class="line">&#125;</span><br><span class="line">org &#123;</span><br><span class="line">    whoami</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同一个 server 但是负责不同 zone 的解析，有不同插件链。</p>
<p>定义 <code>Reverse Zone</code></p>
<p>跟其他 DNS 服务器类似，Corefile 也可以定义 Reverse Zone：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0.0.10.in-addr.arpa &#123;</span><br><span class="line">    whoami</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者简化版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.0/24 &#123;</span><br><span class="line">    whoami</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用不同的通信协议</p>
<p>CoreDNS 除了支持 DNS 协议，也支持 TLS 和 gRPC，即 DNS-over-TLS 和 DNS-over-gRPC 模式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tls://example.org:1443 &#123;</span><br><span class="line">#...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="插件的工作模式"><a href="#插件的工作模式" class="headerlink" title="插件的工作模式"></a>插件的工作模式</h2><p>当 CoreDNS 启动后，它将根据配置文件启动不同 server ，每台 server 都拥有自己的插件链。当有 DNS 请求时，它将依次经历如下 3 步逻辑：</p>
<ol>
<li><p>如果有当前请求的 server 有多个 zone，将采用贪心原则选择最匹配的 zone；</p>
</li>
<li><p>一旦找到匹配的 server，按照 plugin.cfg 定义的顺序执行插件链上的插件；</p>
</li>
<li><p>每个插件将判断当前请求是否应该处理，将有以下几种可能：</p>
</li>
</ol>
<ul>
<li>请求被当前插件处理</li>
</ul>
<p>插件将生成对应的响应并回给客户端，此时请求结束，下一个插件将不会被调用，如 whoami 插件；</p>
<ul>
<li>请求不被当前插件处理</li>
</ul>
<p>直接调用下一个插件。如果最后一个插件执行错误，服务器返回 SERVFAIL 响应；</p>
<ul>
<li>请求被当前插件以 Fallthrough 形式处理</li>
</ul>
<p>如果请求在该插件处理过程中有可能将跳转至下一个插件，该过程称为 fallthrough，并以关键字 fallthrough 来决定是否允许此项操作，例如 host 插件，当查询域名未位于 /etc/hosts，则调用下一个插件；</p>
<ul>
<li>请求在处理过程被携带 Hint</li>
</ul>
<p>请求被插件处理，并在其响应中添加了某些信息（hint）后继续交由下一个插件处理。这些额外的信息将组成对客户端的最终响应，如 metric 或者 prometheus 插件；</p>
<h2 id="CoreDNS-如何处理-DNS-请求"><a href="#CoreDNS-如何处理-DNS-请求" class="headerlink" title="CoreDNS 如何处理 DNS 请求"></a>CoreDNS 如何处理 DNS 请求</h2><p>如果 Corefile 为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">coredns.io:5300 &#123;</span><br><span class="line">    file /etc/coredns/zones/coredns.io.db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example.io:53 &#123;</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">    file /etc/coredns/zones/example.io.db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example.net:53 &#123;</span><br><span class="line">    file /etc/coredns/zones/example.net.db</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.:53 &#123;</span><br><span class="line">    errors</span><br><span class="line">    log</span><br><span class="line">    health</span><br><span class="line">    rewrite name foo.example.com foo.default.svc.cluster.local</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从配置文件来看，我们定义了两个 server（尽管有 4 个区块），分别监听在 5300 和 53 端口。其逻辑图可如下所示：</p>
<img src="/2018/11/21/dns详解/query-processing.png" title="This is an dns image">
<p>每个进入到某个 server 的请求将按照 plugin.cfg 定义顺序执行其已经加载的插件。</p>
<p>从上图，我们需要注意以下几点：</p>
<p>尽管在 .:53 配置了 health 插件，但是它并未在上面的逻辑图中出现，原因是：该插件并未参与请求相关的逻辑（即并没有在插件链上），只是修改了 server 配置。更一般地，我们可以将插件分为两种：</p>
<p>Normal 插件：参与请求相关的逻辑，且插入到插件链中；</p>
<p>未注册插件：不参与请求相关的逻辑，也不出现在插件链中，只是用于修改 server 的配置，如 health，tls 等插件；</p>
<ul>
<li>bind - 绑定哪个端口</li>
<li>root - 设置插件查找目录</li>
<li>health - http健康检查点</li>
</ul>
<p>插件解析：插件由Setup，Registration和Handler部分组成。</p>
<ul>
<li>Setup 解析插件配置和指令</li>
<li>Handler是处理查询并实现所有逻辑的代码。</li>
<li>Registration在CoreDNS编译中注册插件。 服务可以使用注册的所有插件。CoreDNS的配置文件Corefile决定每个服务器运行时使用哪个插件。</li>
</ul>
<p>插件文档: 每个插件都有自己的Readme,详细说明了如何配置它。自述文件包括用户应注意的示例和其他位。所有插件都在 <a href="https://coredns.io/plugins" target="_blank" rel="noopener">插件汇总页</a>上  。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>CoreDNS支持灵活的配置项。 但要确定插件编译到CoreDNS。 我们提供的二进制文件包含plugin.cfgz中列的所有插件.添加或删除很简单 ，但需要重新编译CoreDNS。</p>
<p>因此，大多数用户使用Corefile配置CoreDNS。 当CoreDNS启动，并且没有给出-conf标志时，它将在当前目录中查找名为Corefile的文件。 该文件由一个或多个服务器块组成。 每个服务器块列出一个或多个插件。 这些插件可以进一步配置指令。</p>
<p>Corefile 中插件的排序不确定插件链的顺序。 执行插件的顺序由plugin.cfg的顺序plugin.cfg 。</p>
<p>Corefile中的注释以#开头。 然后该行的其余部分被视为注释评论。</p>
<h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>CoreDNS在其配置中支持环境变量。 它们可以在Corefile中的任何位置使用。 语法是$ENV_VAR （也支持类似Windows的语法%ENV_VAR% ）。 CoreDNS在解析Corefile时替换变量的内容。</p>
<h3 id="导入其他文件"><a href="#导入其他文件" class="headerlink" title="导入其他文件"></a>导入其他文件</h3><p>请参阅<a href="https://coredns.io/explugins/import" target="_blank" rel="noopener">导入插件</a>。 这个插件有点特别之处在于它可以在Corefile中的任何地方使用。</p>
<h4 id="可重复使用的片段"><a href="#可重复使用的片段" class="headerlink" title="可重复使用的片段"></a>可重复使用的片段</h4><p>导入文件的一个特例是<code>snippet</code> 。 通过使用特殊语法命名块来定义片段。 名称必须放在括号中:<code>(name)</code>。 之后，它可以使用import插件包含在配置的其他部分中：</p>
<blockquote>
<p><code>#define a snippet</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(snip) &#123;</span><br><span class="line">	prometheus</span><br><span class="line">log</span><br><span class="line">errors</span><br><span class="line">&#125;</span><br><span class="line">. &#123;</span><br><span class="line">	whoami</span><br><span class="line">	import snip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="服务器块"><a href="#服务器块" class="headerlink" title="服务器块"></a>服务器块</h3><p>每个服务器块都以Server应具有权威性的区域开头。 在区域名称或区域名称列表（用空格分隔）之后，将打开一个带有左括号的服务器块。 使用右大括号关闭服务器块。 以下服务器块指定负责根区域下所有区域的服务器： . ; 基本上，此服务器应处理每个可能的查询：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line"> # Plugins defined here.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>服务器块可以选择指定要侦听的端口号。 默认为端口53（DNS的标准端口）。 指定端口是通过列出以冒号分隔的区域后的端口来完成的。 此Corefile指示CoreDNS创建侦听端口1053的服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.:1053 &#123;</span><br><span class="line"># Plugins defined here.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果您明确定义服务器的侦听端口， 则无法使用-dns.port选项指定它。</p>
</blockquote>
<p>使用已分配给服务器并在同一端口上运行它的区域指定服务器块是一个错误。 此Corefile将在启动时生成错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.:1054 &#123; &#125;</span><br><span class="line">.:1054 &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>将第二个端口号更改为1055会使这些服务器阻塞两个不同的服务器。</p>
<h4 id="指定协议"><a href="#指定协议" class="headerlink" title="指定协议"></a>指定协议</h4><p>目前，CoreDNS接受三种不同的协议：普通DNS，基于TLS的DNS和基于gRPC的DNS。 您可以通过在区域名称前加上方案前缀来指定服务器配置中服务器应接受的内容。</p>
<ul>
<li>dns://用于纯DNS（如果未指定方案，则为默认值）。</li>
<li>tls://用于DNS over TLS。</li>
<li>grpc://用于DNS over gRPC。</li>
</ul>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>每个服务器块都指定了应为此特定服务器链接的多个插件。 在最简单的形式中，您可以通过在服务器块中使用其名称来添加插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line">chaos</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>chaos</code>插件使得CoreDNS在CH类中回答查询 - 这对于识别服务器非常有用。 通过上述配置，CoreDNS将在收到请求时回答其版本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ dig @localhost -p 1053 CH version.bind TXT</span><br><span class="line">...</span><br><span class="line">;; ANSWER SECTION: version.bind. 0 CH TXT &quot;CoreDNS-1.0.5&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>大多数插件允许使用Directives进行更多配置。 在使用chaos插件的情况下，我们可以指定一个VERSION和AUTHORS ，如其语法所示：</p>
<p>chaos [VERSION] [AUTHORS…]</p>
<blockquote>
<p>VERSION是要返回的版本。 默认为CoreDNS-<version> ，如果未设置。</version></p>
</blockquote>
<blockquote>
<p>AUTHORS是作者的名称。 没有默认值。<br>因此，这为chaos插件添加了一些指令，这将使CoreDNS以<code>CoreDNS-001</code>作为其版本响应：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line">	chaos CoreDNS-001 info@coredns.io</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其他具有更多配置选项的插件有一个插件块，就像服务器块一样，它包含在一个开合括号中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line">	plugin &#123;</span><br><span class="line">		 # Plugin Block</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以将所有这些结合起来并拥有以下Corefile，它在两个不同的端口上设置4个区域：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">coredns.io:5300 &#123;</span><br><span class="line">    file db.coredns.io</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example.io:53 &#123;</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    file db.example.io</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">example.net:53 &#123;</span><br><span class="line">    file db.example.net</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.:53 &#123;</span><br><span class="line">    kubernetes</span><br><span class="line">    proxy . 8.8.8.8</span><br><span class="line">    log</span><br><span class="line">    errors</span><br><span class="line">    cache</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当CoreDNS解析时，解析步骤和结果如下：</p>
<img src="/2018/11/21/dns详解/CoreDNS-Corefile.png" title="This is an example image">
<h3 id="外部插件"><a href="#外部插件" class="headerlink" title="外部插件"></a>外部插件</h3><p>外部插件是未编译到默认CoreDNS中的插件。 您可以轻松启用它们，但您需要自己编译CoreDNS。</p>
<h3 id="可能的错误"><a href="#可能的错误" class="headerlink" title="可能的错误"></a>可能的错误</h3><p><code>health</code> 插件的文档说明“此插件只需要启用一次”，这可能会让您认为这将是一个有效的Corefile：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">health</span><br><span class="line">. &#123;</span><br><span class="line">  whoami</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但这不起作用，并导致一个诡异的错误：</p>
<p><code>&quot;Corefile:3 - Error during parsing: Unknown directive &#39;.&#39;&quot;.</code></p>
<p>这里发生了什么？ <code>health</code>被视为一个区域（以及服务器块的开始）。 解析器期望看到插件名称（ cache ， etcd ，等等），而是下一个标记. ，这不是一个插件。 Corefile应该构造如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line"> 	whoami</span><br><span class="line"> 	health</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>health插件文档中的那一行意味着一旦指定了运行health插件 ，它就是整个CoreDNS进程的全局，即使您只为一个服务器指定了它。</p>
<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><p>在这里，您可以找到CoreDNS的一系列配置。 所有设置都是在假设您不是root用户的情况下完成的，因此无法在端口53上开始侦听。我们将使用-dns.port标志来使用端口1053。 在每个设置中，使用的配置文件是CoreDNS的默认名称Corefile 。 这意味着我们不需要使用-conf标志指定配置文件。 换句话说，我们使用./coredns -dns.port=1053 -conf Corefile启动CoreDNS，它可以缩写为./coredns -dns.port=1053 。</p>
<p>所有DNS查询都将使用dig工具生成， dig工具是调试DNS的黄金标准。 我们在这里使用的完整命令行是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ dig -p 1053 @localhost +noall +answer &lt;name&gt; &lt;type&gt;</span><br></pre></td></tr></table></figure>
<p>简短点写<code>dig www.example.org A</code> 等同于<code>dig -p 1053 @localhost +noall +answer www.example.org A</code></p>
<h3 id="权威服务的文件"><a href="#权威服务的文件" class="headerlink" title="权威服务的文件"></a>权威服务的文件</h3><p>此设置使用<code>file</code>插件。 请注意，外部<code>redis</code>插件可以从Redis数据库中进行权威服务。 让我们继续使用<code>file</code>插件进行设置。</p>
<p>我们创建的一个DNS区域文件，它可以有任何名称（ <code>file</code>插件不关心）。 我们放在文件中的数据是针对zone <code>example.org</code>. 。</p>
<p>在当前目录中，创建一个名为<code>db.example.org</code>的文件，并填写以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ORIGIN example.org.</span><br><span class="line">@	3600 IN	SOA sns.dns.icann.org. noc.dns.icann.org. (</span><br><span class="line">				2017042745 ; serial</span><br><span class="line">				7200       ; refresh (2 hours)</span><br><span class="line">				3600       ; retry (1 hour)</span><br><span class="line">				1209600    ; expire (2 weeks)</span><br><span class="line">				3600       ; minimum (1 hour)</span><br><span class="line">				)</span><br><span class="line"></span><br><span class="line">	3600 IN NS a.iana-servers.net.</span><br><span class="line">	3600 IN NS b.iana-servers.net.</span><br><span class="line"></span><br><span class="line">www     IN A     127.0.0.1</span><br><span class="line">        IN AAAA  ::1</span><br></pre></td></tr></table></figure>
<p>最后两行定义了一个名称<code>www.example.org</code>. 有两个地址，127.0.0.1和（IPv6）:: 1。</p>
<p>接下来，创建处理该域查询的最小Corefile ，并添加<code>log</code>插件以启用查询日志记录：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">example.org &#123;</span><br><span class="line">    file db.example.org</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动CoreDNS并使用dig查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dig www.example.org AAAA</span><br><span class="line"></span><br><span class="line">www.example.org.    3600    IN  AAAA    ::1</span><br></pre></td></tr></table></figure>
<p>查看log插件的效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">::1 - [22/Feb/2018:10:21:01 +0000] &quot;AAAA IN www.example.org. udp 45 false 4096&quot; NOERROR qr,aa,rd,ra 121 170.195µs</span><br></pre></td></tr></table></figure>
<p>上面的日志向我们展示了CoreDNS从（ ::1 ）回复的地址以及它回复的时间和日期。 此外，它记录查询类型，查询类，查询名称，使用的协议（ udp ），传入请求的字节大小，DO位状态和公布的UDP缓冲区大小。 这是来自传入查询的数据。 NOERROR指示回复的开始，即回送的响应代码，然后是回复上的标志集： qr,aa,rd,ra ，回复的大小（以字节为单位）（121），以及持续时间得到答复。</p>
<h3 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h3><p>CoreDNS可以配置为将流量转发到recursor。 我们目前有两个插件，允许这个， <code>proxy</code>和<code>forward</code> 。 在这里，我们将使用<code>forward</code>并专注于最基本的设置：转发到Google Public DNS（8.8.8.8）和Quad9 DNS（9.9.9.9）。</p>
<p>除了具有我们想要的配置的Corefile之外，我们不需要创建任何东西。 在这种情况下，我们希望所有符合CoreDNS的查询都转发到8.8.8.8或9.9.9.9：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line">    forward . 8.8.8.8 9.9.9.9</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意， forward和proxy允许您微调它将向上游发送的名称。 在这里，我们选择了所有名称（ . ）。 例如： <code>forward example.com 8.8.8.8 9.9.9.9</code>只会在<code>example.com.</code>转发</p>
<p>启动CoreDNS并使用dig测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ dig www.example.org AAAA</span><br><span class="line"></span><br><span class="line">www.example.org. 25837 IN AAAA 2606:2800:220:1:248:1893:25c8:194</span><br></pre></td></tr></table></figure>
<p>在日志中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1 - [22/Feb/2018:10:34:39 +0000] 36325 &quot;AAAA IN www.example.org. udp 45 false 4096&quot; NOERROR qr,rd,ra,ad 73 1.859369ms</span><br></pre></td></tr></table></figure>
<p>有关此日志行传达的内容，请参阅“ 权威服务”部分。</p>
<h3 id="转发域到不同的上游"><a href="#转发域到不同的上游" class="headerlink" title="转发域到不同的上游"></a>转发域到不同的上游</h3><p>您可能遇到的一个常见情况是， example.org查询需要转到8.8.8.8，其余的应该通过/etc/resolv.conf的名称服务器来解析。 有两种方法可以在Corefile中实现; 一种可行的方式（取决于插件的实现）和一种保证工作的方式。</p>
<p>以此Corefile为例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line">    forward example.org 8.8.8.8</span><br><span class="line">    forward . /etc/resolv.conf</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>目的是获取所有可能的查询（此服务器块对根域具有权威性），然后使用<code>forword</code>插件的按区域过滤。警报：这不起作用。 原因是<code>forword</code>插件只能在服务器块中使用一次（它用于静默覆盖以前的配置;现在上面的配置会触发错误）。</p>
<p>上面的用例是非常有效的，那么如何在CoreDNS中实现呢？ 快速回答是使用多个服务器块，每个服务器块对应要路由的每个域。 这样做会产生这个Corefile：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">example.org &#123;</span><br><span class="line">    forward . 8.8.8.8</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">. &#123;</span><br><span class="line">    forward . /etc/resolv.conf</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这使域路由到CoreDNS，CoreDNS也处理DS查询等特殊情况。 有两个较小的服务器块而不是一个没有负面影响，除了你的Corefile会稍长。 像<code>snippets</code>和导入的东西将有助于那里。</p>
<h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><p>Federation<br>Autopath<br>Metrics<br>Caching</p>
<h3 id="递归解析器"><a href="#递归解析器" class="headerlink" title="递归解析器"></a>递归解析器</h3><p>CoreDNS没有本机（即Go编写）递归解析器，但有一个利用libunbound的（外部）插件。 要使此设置生效，首先必须重新编译CoreDNS并启用未绑定的插件 。 这里有超快速入门（您必须安装CoreDNS 源 ）：</p>
<p>添加unbound:github.com/coredns/unbound到plugin.cfg 。<br>做一个go generate ，然后make 。<br>注意： 未绑定的插件需要编译cgo，这也意味着coredns二进制文件现在已经链接到libunbound而不再是静态二进制文件。</p>
<p>假设这有效，您可以使用以下Corefile启用unbound ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. &#123;</span><br><span class="line">    unbound</span><br><span class="line">    cache</span><br><span class="line">    log</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>已包含缓存 ，因为禁用了来自未绑定的（内部）缓存，以允许缓存的指标正常工作。</p>
<h3 id="编写插件"><a href="#编写插件" class="headerlink" title="编写插件"></a>编写插件</h3><p>如本手册前面所述，插件是使CoreDNS发挥作用的因素。 我们在上一节中已经看到了一堆配置，但是你怎么能编写自己的插件？</p>
<p>有关此主题的较旧帖子，请参阅为<a href="https://coredns.io/2016/12/19/writing-plugins-for-coredns/" target="_blank" rel="noopener">CoreDNS编写插件</a> 。 CoreDNS源代码中记录的plugin.md也有一些背景知识，并讨论了如何设置README.md的样式。</p>
<p>规范示例插件是示例插件。 它的github存储库显示了创建插件所需的最小代码（带有测试！）。</p>
<p>它有：</p>
<p>1.setup.go和setup_test.go ，它们实现从Corefile解析配置。 每当Corefile解析器看到插件的名称时，就会调用（通常命名的） setup函数; 在这种情况下，“示例”。</p>
<ol start="2">
<li>example.go （通常命名为&lt;plugin_name&gt;.go ），其中包含用于处理查询的逻辑，以及example_test.go ，它具有基本单元测试以检查插件是否有效。</li>
<li>以Unix手册形式记录的README.md如何配置此插件。</li>
<li>LICENSE文件。 要包含在CoreDNS中，这需要具有类似APL的许可证。<br>该代码也有广泛的评论; 随意分叉它并使你的插件基于它。</li>
</ol>
<h3 id="如何调用插件"><a href="#如何调用插件" class="headerlink" title="如何调用插件"></a>如何调用插件</h3><p>当CoreDNS想要使用插件时，它会调用方法ServeDNS 。 ServeDNS有三个参数：</p>
<ul>
<li>a context.Context ;</li>
<li>a dns.ResponseWriter ，它基本上就是客户端的连接;</li>
<li>a *dns.Msg是来自客户端的请求。<br>ServeDNS返回两个值：（响应）代码和错误。 在此服务器中使用<code>error</code>时会记录该错误 。</li>
</ul>
<p>代码告诉CoreDNS是否已经通过插件链写入了回复 。 在后一种情况下，CoreDNS将负责这一点。 对于代码的值，我们重用 dns包中的DNS返回码（rcodes）。</p>
<p>CoreDNS反馈：</p>
<ul>
<li>SERVFAIL（dns.RcodeServerFailure）</li>
<li>REFUSED（dns.RcodeRefused）</li>
<li>FORMERR（dns.RcodeFormatError）</li>
<li>NOTIMP（dns.RcodeNotImplemented）<br>作为特殊的，然后假设没有任何内容写入客户端。 在所有其他情况下，它假定已经向客户端写入了某些内容（通过插件）。</li>
</ul>
<p>请参阅<a href="https://blog.coredns.io/2017/03/01/how-to-add-plugins-to-coredns/" target="_blank" rel="noopener">此文章</a> ，了解如何使用您的插件编译CoreDNS。</p>
<h3 id="从插件中记录"><a href="#从插件中记录" class="headerlink" title="从插件中记录"></a>从插件中记录</h3><p>如果您的插件需要输出日志行，则应使用log包。 CoreDNS未实现日志级别。 标准输出方式是： log.Printf(“[LEVEL] …”) ，LEVEL可以是： INFO ， WARNING或ERROR 。</p>
<p>通常，返回错误时应将记录留给较高层。 但是，如果有理由消耗错误但仍然通知用户，则可以接受登录插件。</p>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><p>导出指标时， 命名空间应该是plugin.Namespace （=“coredns”）， 子系统应该是插件的名称。 然后，插件的README.md还应包含详细说明度量标准的度量标准部分。 如果插件支持动态健康报告，它还应该有一个健康部分详细说明它的一些内部工作。</p>
<h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><p>每个插件都应该有一个README.md来解释插件的功能以及配置方式。 该文件应具有以下布局：</p>
<ul>
<li>标题：使用插件的名称</li>
<li>标题为“已命名”的子部分，带有<plugin name=""> - <one line="" description=""> ，即名称删除说明</one></plugin></li>
<li>标题为“描述”的子部分，具有更长的描述以及插件支持的所有选项。</li>
<li>标题为“语法”的小节，详细说明语法和支持的指令。</li>
<li>标题为“实例”的小节。</li>
<li>标题为“另请参阅”的可选子部分，引用外部文档，如IETF RFC。</li>
<li>标题为“Bugs”的可选子部分列出了尚未使用的内容。</li>
<li>当然，更多部分是可能的。</li>
</ul>
<p>样式<br>我们使用Unix手册页样式：</p>
<ul>
<li>正在运行的文本中插件的名称应为斜体： <em>plugin</em> 。</li>
<li>运行文本引用中的所有CAPITAL用户提供的参数都使用强文本： <strong>EXAMPLE</strong> 。</li>
<li>可选文本在块引号中： [optional] 。</li>
<li>使用三个点表示允许多个选项： arg…</li>
<li>使用的文字： literal 。<h3 id="示例域名"><a href="#示例域名" class="headerlink" title="示例域名"></a>示例域名</h3>请务必在您提供的任何示例和测试中使用example.org或example.net 。 这些是为此目的创建的标准域名。 如果您不这样做，您的幻想域名可能会被某人注册，并且实际上会提供Web内容（您可能喜欢或不喜欢）。</li>
</ul>
<h2 id="Fallthrough"><a href="#Fallthrough" class="headerlink" title="Fallthrough"></a>Fallthrough</h2><p>在一个完美的世界中，插件的情况如下：“你是否对区域负责”。 如果答案是“不”，则插件应该调用链中的下一个插件。 如果“是”，它应该处理属于该区域的所有名称和下面的名称 - 即它应该处理整个域和所有子域。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TODO（miek）：ref to “Query Is Proccessed with Fallthrough”</span><br><span class="line">. &#123;</span><br><span class="line">    file example.org db.example</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在此示例中， 文件插件正在处理以下（包括） example.org所有名称。 如果查询不是子域（或等于） example.org ，则调用下一个插件。</p>
<p>现在，世界并不完美，并且有充分的理由“穿透”到下一个中​​间件，这意味着插件只负责区域内的一个名称子集 。 第一个出现的是反向插件，它合成了PTR和A / AAAA响应（对IPv6很有用）。</p>
<p>反向插件的本质是它只处理A / AAAA和PTR，然后只处理名称的子集。 理想情况下，您可能希望在另一个插件（如文件或自动 （甚至代理 ）） 前面进行 反向分层。 这意味着反向处理一些特殊的反向情况， 所有其他请求由后备插件处理。 这正是“穿透”所做的。 为了明确说明，我们选择实现此类行为的插件应实现fallthrough关键字。</p>
<p>fallthrough指令应该可以选择接受区域列表。 只允许对其中一个区域中的记录进行查询。</p>
<h3 id="Qualifying-for-main-repo"><a href="#Qualifying-for-main-repo" class="headerlink" title="Qualifying for main repo"></a>Qualifying for main repo</h3><p>CoreDNS的插件可以在规则外。 plugin.cfg默认为CoreDNS的repo，但外部repos工作正常。 那么我们什么时候考虑在主回购中包含一个新的插件？</p>
<ul>
<li>插件作者应该愿意维护插件，即你的GitHub句柄将列在其OWNERS文件中。</li>
<li>该插件应该对其他人有用。 “有用”是一个主观术语，但它应该为CoreDNS带来新的东西。</li>
<li>它应该与其他插件充分不同，以保证包含。</li>
<li>需要支持当前的Internet标准：IPv4和IPv6，因此应该处理A和AAAA记录（如果您的插件处理地址记录，那就是）。</li>
<li>它必须有测试。</li>
<li>它必须有一个README.md文档。</li>
</ul>

      
    </div>

    

    
    
    

    

    
       
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DNS/" rel="tag"># DNS</a>
          
            <a href="/tags/CoreDNS/" rel="tag"># CoreDNS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/16/硬盘接口汇总/" rel="next" title="硬盘接口汇总">
                <i class="fa fa-chevron-left"></i> 硬盘接口汇总
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">cuibq</p>
              <p class="site-description motion-element" itemprop="description">工作生活中总有很多随着时间被遗忘的东西,所以我决定写下来,防止老了记不住</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">4</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">Kategorien</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">6</span>
                    <span class="site-state-item-name">Tags</span>
                  
                </div>
              
            </nav>
          

          

          

          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#CoreDNS手册"><span class="nav-number">1.</span> <span class="nav-text">CoreDNS手册</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#什么是coredns"><span class="nav-number">1.1.</span> <span class="nav-text">什么是coredns</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编译与运行"><span class="nav-number">1.2.</span> <span class="nav-text">编译与运行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Corefile-介绍"><span class="nav-number">1.3.</span> <span class="nav-text">Corefile 介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插件的工作模式"><span class="nav-number">1.4.</span> <span class="nav-text">插件的工作模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CoreDNS-如何处理-DNS-请求"><span class="nav-number">1.5.</span> <span class="nav-text">CoreDNS 如何处理 DNS 请求</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置"><span class="nav-number">1.6.</span> <span class="nav-text">配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境变量"><span class="nav-number">1.6.1.</span> <span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#导入其他文件"><span class="nav-number">1.6.2.</span> <span class="nav-text">导入其他文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#可重复使用的片段"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">可重复使用的片段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务器块"><span class="nav-number">1.6.3.</span> <span class="nav-text">服务器块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#指定协议"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">指定协议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#插件"><span class="nav-number">1.6.4.</span> <span class="nav-text">插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部插件"><span class="nav-number">1.6.5.</span> <span class="nav-text">外部插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可能的错误"><span class="nav-number">1.6.6.</span> <span class="nav-text">可能的错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置"><span class="nav-number">1.6.7.</span> <span class="nav-text">设置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权威服务的文件"><span class="nav-number">1.6.8.</span> <span class="nav-text">权威服务的文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转发"><span class="nav-number">1.6.9.</span> <span class="nav-text">转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转发域到不同的上游"><span class="nav-number">1.6.10.</span> <span class="nav-text">转发域到不同的上游</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Kubernetes"><span class="nav-number">1.6.11.</span> <span class="nav-text">Kubernetes</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#递归解析器"><span class="nav-number">1.6.12.</span> <span class="nav-text">递归解析器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写插件"><span class="nav-number">1.6.13.</span> <span class="nav-text">编写插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何调用插件"><span class="nav-number">1.6.14.</span> <span class="nav-text">如何调用插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#从插件中记录"><span class="nav-number">1.6.15.</span> <span class="nav-text">从插件中记录</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#权重"><span class="nav-number">1.6.16.</span> <span class="nav-text">权重</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文档"><span class="nav-number">1.6.17.</span> <span class="nav-text">文档</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例域名"><span class="nav-number">1.6.18.</span> <span class="nav-text">示例域名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Fallthrough"><span class="nav-number">1.7.</span> <span class="nav-text">Fallthrough</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Qualifying-for-main-repo"><span class="nav-number">1.7.1.</span> <span class="nav-text">Qualifying for main repo</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cuibq</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v6.5.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.5.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.5.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.5.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.5.0"></script>



  



  










  





  

  

  

  

  

  
  

  

  

  

  

  

  

</body>
</html>
